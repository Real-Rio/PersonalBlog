---
layout: "../../layouts/PostLayout.astro"
title: "CMU15445实验和学习笔记"
description: "从0到1搭建一个博客"
pubDate: "2023.10.17"
heroImage: "/images/itemPreview.png"
tags: ["Blog"]
---

## 调试

因为在线测评的样例是不公开的,而本地样例非常简陋,经常出现本地满分通过,在线平台只有六七十分的情况,为了debug,我们可以在每个函数内加上下面这样的语句,这样就可以在测评平台的log中输出调用的函数顺序和参数信息

```c++
 	char loginfo[200];
  snprintf(loginfo, sizeof(loginfo), "echo record access frame_id: %d", frame_id);
  system(loginfo);
```

在明确测评平台的测评文件后,我们也可以直接使用

```c
 system("cat /autograder/../../filename");
```

打印出测试文件,但这个方法有时能成功,有时又不行.如果不行的话就只能用第一种方法慢慢调了

## Project1 

### Task #1 Extendible Hash Table

这一部分内容是实现可拓展哈希,至于为什么不直接使用stl中的**unordered_map**,我的猜测是**unordered_map**在动态增长时是不可控的,而我们自己实现的可拓展哈希在容量不够时从1个bucket分裂成2个bucket,每次容量增加大小即为一个bucket的大小. 因此我们能够实现更精细化的管理

第一遍没跑通的原因是在**Insert**函数下如果bucket容量满了需要分裂,忘记写上num_bucket++



### Task #2 - LRU-K Replacement Policy

> 这节任务主要是在数据库内部实现自己的内存页管理策略,而不是交由操作系统来管理. 上过课的都知道,数据库相比操作系统更接近用户端,更能明白哪些数据库页是接下来还会用到的,哪些页是可以淘汰的,因此在数据库内管理页能比操作系统效率更高



第一次做的时候,在函数**SetEvictable**中没有判断传入的**frame_id**是否在lru-k的管理系统中,导致如果传入了一个没有使用的**frame_id**,函数并没有退出,而是新建了一个管理表项,导致后面出现了bug



## 学习笔记

- DBMS的主要5个层次

<img src="https://cdn.jsdelivr.net/gh/Real-Rio/pictures/img/image-20231017154307961.png" alt="image-20231017154307961" style="zoom:50%;" />



- 非聚集索引和聚集索引的区别

通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据

<img src="https://cdn.jsdelivr.net/gh/Real-Rio/pictures/img/v2-fbb0e0b277cc1177d2e76518793f99cf_1440w.webp" alt="img" style="zoom:50%;" />

- #10中提到,DBMS在处理聚合函数时有两种策略,一种是排序,然后将重复的key进行分组.这种方式的弊端是**distinct**,**group by**等函数是不需要输出结果有序的,排序无疑增加了计算量.第二种策略是哈希.如果所有元素都能装进内存并生成hash table那自然最好,那如果元素很多不能全部放进内存呢?

​	课上介绍了一种先进行**partition**,再进行**rehash**的方法.

<img src="https://cdn.jsdelivr.net/gh/Real-Rio/pictures/img/image-20231017172700513.png" alt="image-20231017172700513" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Real-Rio/pictures/img/image-20231017172840697-20231017173338052.png" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Real-Rio/pictures/img/image-20231017173101784.png" alt="image-20231017173101784" style="zoom:50%;" />

主要思想和外部排序一样,将大的表先分成小块,再对每个小块进行哈希,最后将结果汇总