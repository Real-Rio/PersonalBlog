---
layout: "../../layouts/PostLayout.astro"
title: "test"
description: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
pubDate: "Sep 10 2022"
heroImage: "/post_img.webp"
---

# 南大操作系统学习笔记

https://www.bilibili.com/video/BV12L4y1379V?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=67c06034cc10bda056cebc3a3ea69eb6



## 什么是程序和编译器

程序=计算+系统调用=是一个状态机



- 程序的第一条指令在哪？

> <img src="C:\Users\53094\AppData\Roaming\Typora\typora-user-images\image-20220630113059102.png" alt="image-20220630113059102" style="zoom:50%;" />
>
> 进入**加载器**



## 并发

- 原子性

- 顺序性

  

编译器会优化指令（O~2~，O~3~），CPU也会优化指令（乱序执行，流水线），这使得并发编程很容易出现不在预期之中的结果



### Lock指令现代实现



**X86:**

在 L1 cache 层保持一致性 (ring/mesh bus)

- 相当于每个 cache line 有分别的锁
- store(x) 进入 L1 缓存即保证对其他处理器可见
  - 但要小心 store buffer 和乱序执行

<img src="C:\Users\53094\AppData\Roaming\Typora\typora-user-images\image-20220705003550765.png" alt="image-20220705003550765" style="zoom:80%;" />

CPU1想要加锁，它要处理其他所有CPU中的cache以保持一致性

------

L1 cache line 根据状态进行协调

- M (Modified), 脏值
- E (Exclusive), 独占访问
- S (Shared), 只读共享
- I (Invalid), 不拥有 cache line



**RISC-V Load-Reserved/Store-Conditional (LR/SC):**

LR: 在内存上标记 reserved (盯上你了)，中断、其他处理器写入都会导致标记消除

```assembly
lr.w rd, (rs1)
  rd = M[rs1]
  reserve M[rs1]
```

------

SC: 如果 “盯上” 未被解除，则写入

```assembly
sc.w rd, rs2, (rs1)
  if still reserved:
    M[rs1] = rs2
    rd = 0
  else:
    rd = nonzero
```

### 互斥

---



#### 自旋锁

> 如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗



缺陷：

除了进入临界区的线程，其他处理器上的线程都在空转，带来了性能问题



使用场景：

1. 临界区几乎不 “拥堵”
2. 持有自旋锁时禁止执行流切换



==操作系统内核的并发数据结构 (短临界区)==

保证锁的持有者在很短的时间内可以释放锁



#### 互斥锁

如果线程试图获得锁不能满足，就由操作系统调度进行阻塞态（内核态切换）



---



**自旋锁 (线程直接共享 locked)**

- 更快的 fast path
  - xchg 成功 → 立即进入临界区，开销很小
- 更慢的 slow path
  - xchg 失败 → 浪费 CPU 自旋等待



**互斥锁 (通过系统调用访问 locked)**

- 更快的 slow path
  - 上锁失败线程不再占用 CPU
- 更慢的 fast path
  - 即便上锁成功也需要进出内核 (syscall)



### 同步

- 生产者消费者模型
- 哲学家问题（死锁）



### 线程和协程

==协程==相当于特殊的函数，在用户态运行，切换开销小。一个进程的多个协程仍是串行处理，无法利用多处理器。



> Go: 小孩子才做选择，多处理器并行和轻量级并发我全都要！

Goroutine: 概念上是线程，实际是线程和协程的混合体

- 每个 CPU 上有一个 Go Worker，自由调度 goroutines
- 执行到 blocking API 时 (例如 sleep, read)
  - Go Worker 偷偷改成 non-blocking 的版本
    - 成功 → 立即继续执行
    - 失败 → 立即 yield 到另一个需要 CPU 的 goroutine
      - 太巧妙了！CPU 和操作系统全部用到 100%

![image-20220706124403011](C:\Users\53094\AppData\Roaming\Typora\typora-user-images\image-20220706124403011.png)





### 死锁

必要条件

- 互斥：一个资源每次只能被一个进程使用
- 请求与保持：一个进程请求资阻塞时，不释放已获得的资源
- 不剥夺：进程已获得的资源不能强行剥夺
- 循环等待：若干进程之间形成头尾相接的循环等待资源关系  





## 进程

### OS启动

OS具有初始状态，即电路reset之后硬件的初始状态

- EIP = 0x0000fff0
- CR0 = 0x60000010
  - 16-bit 模式
- EFLAGS = 0x00000002
  - interrupt disabled



启动顺序

1. 加载0xffff0处代码（固件厂商写在ROM中），跳转到bios程序
2. 查找所有磁盘设备，如果前512个字节的最后为0xaa55，说明可启动
3. BIOS 把第一个可引导设备的第一个扇区加载到物理内存的 `7c00` 位置
4. ···



### fork

- 被复制后，整个地址空间都被标记为 “只读”
- 操作系统捕获 Page Fault 后酌情复制页面
- fork-execve 效率得到提升
- 子进程与父进程的地址空间一致，即虚拟地址一致。若子进程进行写操作，映射的物理地址会变，这时才从父进程拷贝数据到独立的内存空间

### execve

- fork完全复制父进程的状态空间，execve用来清空状态，执行心得程序

- 将当前运行的状态机重置成成另一个程序的初始状态

```c
int execve(const char *filename, char * const argv, char * const envp);
```

- 执行名为 `filename` 的程序



### exit

具有几种写法

- exit(0)-stdlib.h中声明的 libc 函数
  - 会调用 `atexit`，退出前flush缓冲区
- _exit(0)-glibc 的 syscall wrapper
  - 执行 “exit_group” 系统调用终止整个进程 (所有线程)
  - 不会调用 `atexit`
- syscall(SYS_exit, 0)
  - 执行 “`exit`” 系统调用终止当前线程
  - 不会调用 `atexit`

> atexit在退出前执行的函数



### 进程加载

- ELF loader将文件用`mmap`映射到内存中
- 进程的初始寄存器状态在手册中规定